<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java, Concurrency, Web">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="Java, Concurrency, Web">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog">
<meta name="twitter:description" content="Java, Concurrency, Web">
  
    <link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Stay hungry, Stay foolish.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java动态编译技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/16/Java动态编译技术/" class="article-date">
  <time datetime="2017-07-16T11:14:04.000Z" itemprop="datePublished">2017-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/16/Java动态编译技术/">Java动态编译技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文链接<a href="https://www.ibm.com/developerworks/java/library/j-jtp12214/index.html?ca=drs-" target="_blank" rel="external">Dynamic compilation and performance measurement</a></p>
<p>最近我在写一篇文章解剖一个写得很烂的评测。毕竟，我们程序员会被用性能来评价，我们都喜欢理解代码的性能特点。当我偶尔写了一点和性能相关的东西时，会收到很多邮件，说为什么我的测试结果和你的不一样。这反映出大家并不了解JVM是如何执行字节码的。现在让我们来看看JVM的底层吧。理解动态编译和优化是理解如何辨别一个好的性能评测的关键。</p>
<h2 id="动态编译简介"><a href="#动态编译简介" class="headerlink" title="动态编译简介"></a>动态编译简介</h2><p>Java程序的编译过程不同于其他静态语言比如C和C++。静态编译器把源代码直接转化为可以直接执行的机器码，不同的硬件平台需要不同的编译器。Java编译器把源代码转化为可移植的JVM字节码，这可以被看作是JVM的机器码。不同于其他静态编译器的是，javac几乎不做任何优化，那些可能的优化是在运行时发生的。</p>
<p>第一代JVM是完全解释性的，JVM只是解释机器码而不编译执行。这种方式显然不能提供最好的性能，因为系统花了更多的时间执行解释器而不是应用程序本身。</p>
<h4 id="即时编译器JIT"><a href="#即时编译器JIT" class="headerlink" title="即时编译器JIT"></a>即时编译器JIT</h4><p>在原型验证阶段，解释执行是不错的，但是早期的JVM被评价运行太慢。后面的一代JVM使用了JIT编译器加速执行。严格的说，基于JIT的虚拟机在执行前，把所有的字节码编译成机器码，但是是以一种懒惰(lazy)的方式：JIT只编译它知道的即将被执行的那一些代码，所以称之为即时编译器。这种方法允许程序更快的启动，因为不需要等待耗时的编译过程。</p>
<p>JIT看起来不错，但存在一些缺陷。JIT编译避免了解释器的消耗，但是代码优化的级别是不足的。为了避免启动太慢，JIT编译器必须快，这意味着它不能花太多时间优化。早期的JIT编译器在函数内联化这点上是比较保守的，因为它不知道稍后会载入什么类。</p>
<p>虽然技术上讲，基于JIT的虚拟机会把每一个字节码都编译为机器码，术语JIT经常用于指代任何从字节码到机器码的动态转换过程。</p>
<h4 id="HotSopt动态编译"><a href="#HotSopt动态编译" class="headerlink" title="HotSopt动态编译"></a>HotSopt动态编译</h4><p>HotSpot执行过程结合了解释、性能监测和动态编译。不是把所有字节码都转换为机器码，HotSpot首先以解释器模式运行，只编译那些hot的代码，指执行频繁的那些。HotSpot在运行时会收集性能监测数据，用于决定哪些代码段执行得频繁到值得将其编译为机器码。只编译频繁执行的代码有几个性能优势：不会有时间浪费在编译不频繁执行的代码上，因此有更多的时间用于优化hot的代码。另外，通过延迟编译，编译器有了性能监测数据，可以做出更好的优化，比如把哪些函数设置为内联函数。</p>
<p>HotSpot有两个编译器，客户编译器和服务器编译器。默认的是使用客户编译器，你可以在JVM启动时使用-server参数选择用哪个。服务器编译器的目标是最大化运行速度的峰值，主要用于长期运行的服务器程序。客户端编译器的目标是降低应用的启动时间和内存占用，相比于server版本使用了更少的复杂优化技术，所以编译速度也更快。</p>
<p>HotSpot服务器版编译器可以运行很多种优化技术。它拥有许多在静态编译器中存在的技术，比如代码提升(code hoisting)，公共子表达式抽取，训练展开，范围检查清除，无用代码剔除，数据流分析以及很多在静态编译语言中不可行的优化技术，比如激进的函数内联。</p>
<h4 id="持续再编译"><a href="#持续再编译" class="headerlink" title="持续再编译"></a>持续再编译</h4><p>HotSpot的另一个有趣的方面是是否编译某段代码并不是一次性决定的。如果某段代码被解释的次数达到了某个阈值，它会被编译为机器码。并且，JVM会持续的监测代码性能，可能会多次编译同一段代码，使用越来高层级的优化技术，如果那段代码真的特别hot或者监测数据提供了额外的优化可能。你可以加上-XX:+PrintCompilation启动JVM，看到编译过程的更多细节。</p>
<h4 id="栈上置换-on-stack-replacement"><a href="#栈上置换-on-stack-replacement" class="headerlink" title="栈上置换(on-stack replacement)"></a>栈上置换(on-stack replacement)</h4><p>最初版本的HotSpot一个时间只编译一个方法。一个方法被认为是Hot的，条件是它被累计执行了超过某个数（在最初版本的HotSpot版本中，这个数字是1万)，所以每个方法有一个关联的计数器，每次执行时加一。然而，方法被编译后，直到这个方法退出后再进入时才会被替换为编译版本，编译版本只会被用于后续执行。这样做可能会出现编译后的版本没被用到一次的情况，比如对于计算密集型的程序，所有的计算过程都是在单次方法调用中完成的。</p>
<p>新近版本的HotSpot使用了一种称为栈上置换的技术，允许在循环过程中，代码段切换到编译后的版本。</p>
<h2 id="这和benchmark有什么关系？"><a href="#这和benchmark有什么关系？" class="headerlink" title="这和benchmark有什么关系？"></a>这和benchmark有什么关系？</h2><p>我说这是一篇和benchmark相关的文章，但是目前未知你读到的是历史的教训和HotSpot的相关原理。我绕这么大圈子的原因是，如果不理解动态编译过程，几乎不可能正确的编写或解释Java类的性能测试。（其实即使有了较深的了解，那也相当难）</p>
<h4 id="为Java编写评测程序比C语言困难很多"><a href="#为Java编写评测程序比C语言困难很多" class="headerlink" title="为Java编写评测程序比C语言困难很多"></a>为Java编写评测程序比C语言困难很多</h4><p>传统的判断方法A是否比方法B更快的方式是写一个评测程序，通常被称为microbenchmark。这种倾向并不是完全合理的。科学的方法不能缺少独立的调查。魔鬼总是藏在细节中。为动态编译语言编写评测远比静态语言更加困难和复杂。通过编写一些用例程序，来了解一个类的性能并没有错，但是对于Java，很可能评测程序告诉你的和你想象的不一样。</p>
<p>对于一个C程序，你可以很大程度上了解它的性能特点，甚至不需要运行它，只需要看看它编译后的机器码。那些生成的指令就是实际被执行的机器码，它们的性能特征大都是已知的。</p>
<p>如果编译器决定优化掉某段代码，因为它推断出那段代码任何作用都没有，你可以在生成的机器码中发现这种行为，因为那段代码不见了。所以通常不需要运行多长时间你就可以合理的推断出代码的性能特征。</p>
<p>另一方面，HotSpot JIT是持续的重新编译Java字节码为机器码，重编译的触发时间是不可预知的，可能是达到了执行次数的阈值，可能是新载入一个类，也可能是执行的代码已经被装入但还没执行过。在持续编译的环境中，测量代码的执行时间是非常不准确的，通常需要运行很长一段时间才能获得有意义的数据。</p>
<h2 id="无用代码消除"><a href="#无用代码消除" class="headerlink" title="无用代码消除"></a>无用代码消除</h2><p>写出好评测的一个挑战是，编译器特别擅长消除无用的代码，指的是那些对程序执行结果不会有任何影响的代码。但是评测程序通常不会产生任何输出，这意味着你的部分甚至所有代码会被优化掉，而你不会意识到是编译器的作用，只是观察到执行时间比预计少了很多。尤其是使用server版编译器时，运行速度会比使用client版编译器快很多，不是因为编译速度快，而是server版编译器更擅长去掉无用的代码。不幸的是，它能够在评测中让程序变得更短，然而在真实环境中，不会有那么多无用代码。</p>
<h4 id="一个离奇的结果"><a href="#一个离奇的结果" class="headerlink" title="一个离奇的结果"></a>一个离奇的结果</h4><p>下面的代码是一个评测，包含了一段无用的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StupidThreadTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomeStuff</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">double</span> uselessSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>; j++) &#123;</div><div class="line">                uselessSum += (<span class="keyword">double</span>) i + (<span class="keyword">double</span>) j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        doSomeStuff();</div><div class="line">         </div><div class="line">        <span class="keyword">int</span> nThreads = Integer.parseInt(args[<span class="number">0</span>]);</div><div class="line">        Thread[] threads = <span class="keyword">new</span> Thread[nThreads];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nThreads; i++)</div><div class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; doSomeStuff(); &#125;</div><div class="line">            &#125;);</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++)</div><div class="line">            threads[i].start();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++)</div><div class="line">            threads[i].join();</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"Time: "</span> + (end-start) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doSomeStuff()</code>方法应该交给线程一些任务做，所以我们可以从输入的时间推断出线程调度的成本的一些特性。然而，编译器可以认为<code>doSomeStuff()</code>整段程序都是无用的，然后全部优化掉。表1展示了<code>StupidThreadBenchmark</code>在server编译器和client编译器条件下的运行时间。两种JVM都显示运行时间和线程数量的近似线性关系，但是表中的数据可能会被误解为server版本的JVM比client版快20倍。实际上，server版只是做了更多的优化，去掉更多的无用代码。虽然许多程序确实可以在server版JVM上获得性能提升，但是这里你看到的加速只能被解读为这个评测写得多么差劲。</p>
<h5 id="表1"><a href="#表1" class="headerlink" title="表1"></a>表1</h5><table>
<thead>
<tr>
<th>Number of threads</th>
<th>Client JVM run time</th>
<th style="text-align:left">Server JVM run time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>43</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td>100</td>
<td>435</td>
<td style="text-align:left">10</td>
</tr>
<tr>
<td>1000</td>
<td>4142</td>
<td style="text-align:left">80</td>
</tr>
<tr>
<td>10000</td>
<td>42402</td>
<td style="text-align:left">1060</td>
</tr>
</tbody>
</table>
<p>过度的无用代码消除也是评测静态编译语言的一个问题。然而，在那些语言中，如果编译器去掉了一大块代码，是很容易从编译后的代码中发现的。动态编译语言中，你访问不到这样的信息。</p>
<h2 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h2><p>如果你想测量X的性能，你想测量的是它编译后的代码的性能，而不是被解释执行的性能。达到这个目的需要预热JVM，执行目标操作足够多的次数后，编译器会把目标操作替换为编译后的版本。</p>
<p>使用早期的JIT和没有栈上置换功能的编译器，有一种简单的衡量程序的编译版本性能的方式，先调用一定次数，才启动计时器，然后再执行一些次数。如果预热的执行次数超过了触发编译的阈值，计时的那部分调用是运行的编译后的代码。并且，编译的时间成本是在计时器开始前发生的。</p>
<p>使用新的动态编译器，情况就困难很多了。编译器运行的次数难以预测，JVM按照自己的想法编译代码，并且同一份代码可能会在运行时被编译多次。如果你没有考虑到这些事件的时间，它们会严重的污染你的计时结果。</p>
<p>图1展示了预计不到的动态编译可能导致的计时污染。假如你准备运行一个20万次的迭代，编译代码比解释执行快十倍。如果编译发生在第20万次迭代，你计算的只是解释执行的时间。如果编译在10万次发生，你的整个运行时间是10万次解释执行，加上编译时间，再加上10万次编译执行。如果运行2万次编译就发生了，那么整个运行时间是2万次解释执行，加上编译时间和18万次编译执行。因为你不知道编译器在何时运行，会运行多久，所以评测结果可能会被严重污染。取决于编译发生的时间和编译后代码的速度，迭代次数的小变动可能会导致”性能”的巨大差异。</p>
<p><img src="https://www.ibm.com/developerworks/java/library/j-jtp12214/java_diagram.gif" alt="被动态编译污染的性能评测"></p>
<p>所以，预热到什么程度是合适的？你不知道。你能做的是运行评测的时候加上<code>-XX:+PrintCompilation</code>，观察什么导致编译器介入，然后调整代码的结构，保证所有的编译过程发生在计时器开启之前，并且计时过程中不会再发生编译。</p>
<h4 id="不要忘记GC的存在"><a href="#不要忘记GC的存在" class="headerlink" title="不要忘记GC的存在"></a>不要忘记GC的存在</h4><p>到这里，你已经看到了如果你想获得精确的计时结果，你必须先运行测试代码一定次数以预热JVM。另一方面，如果测试代码有对象分配操作，这会产生垃圾，最后GC会运行。这是另外一个可能会严重污染计时结果的因素，迭代次数的小的变化可能就是没有GC和有一次GC的差别。</p>
<p>如果你使用<code>-verbose:gc</code>运行评测，你可以看到垃圾回收消耗了多少时间然后相应的调整程序。甚至，你可以运行程序很长很长时间，保证触发了很多次垃圾回收，以更好的分摊GC成本。</p>
<h2 id="动态反优化-deoptimization"><a href="#动态反优化-deoptimization" class="headerlink" title="动态反优化(deoptimization)"></a>动态反优化(deoptimization)</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/16/Java动态编译技术/" data-id="cj56ttrpf0003z8jgapy711va" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Brain-Goetz/">Brain Goetz</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/译文/">译文</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入探讨原子性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/16/深入探讨原子性/" class="article-date">
  <time datetime="2017-07-16T06:03:46.000Z" itemprop="datePublished">2017-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/16/深入探讨原子性/">深入探讨原子性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文<a href="https://www.ibm.com/developerworks/java/library/j-jtp11234/index.html?ca=drs-" target="_blank" rel="external">Going Atomic</a></p>
<p>很多年前，多处理器系统是价格高昂的专用系统。现在(2004年)，多处理器系统变得便宜和常见，几乎每个主流的处理器都有内建的多线程支持，有的甚至包含了上百个处理器核心。</p>
<p>为了充分利用多处理器系统，应用程序应该使用多线程。但是，任何写过并发程序的人都知道，简单的把工作分给多个线程并不足以达到好的硬件利用率，必须确保线程把大部分时间花在了运行实际任务上而不是等待锁。</p>
<h2 id="问题：线程协调"><a href="#问题：线程协调" class="headerlink" title="问题：线程协调"></a>问题：线程协调</h2><p>任务并行化几乎都会涉及到线程协调。考虑一个线程池，任务的执行是相互独立的。如果池中的线程同时从一个队列中取出和添加元素，那么这些操作必须是线程安全的，需要协调对链表链表节点的访问。就是这些协调过程，会导致各种各样的问题。</p>
<h4 id="标准解决：锁"><a href="#标准解决：锁" class="headerlink" title="标准解决：锁"></a>标准解决：锁</h4><p>Java的针对共享变量的协调访问的传统解决方法是使用同步，保证访问是在持有锁的前提下进行的。有了同步，可以确保持有锁的线程是独占性的访问变量的，并且对变量的修改会立即对其他线程可见。这种方法的不好的一面是，当多个线程激烈竞争时，吞吐量可能会严重下降，因为同步的成本太高了。（冲突少的情况下，同步成本很低。）</p>
<p>基于锁的算法的另一个问题是，如果一个持有锁的线程挂起了，锁不会被释放，其他线程没有机会获取锁。</p>
<p><code>volatile</code>变量也可以用于共享变量，成本比锁同步低，但是有一定的限制。虽然对<code>volatile</code>变量的写操作一定会对其他线程可见，但是没有办法实现一个<em>读-改-写</em> 的操作序列的原子性，意味着不能使用<code>volatile</code>变量实现锁或计数器。</p>
<h4 id="用锁实现计数器和mutex"><a href="#用锁实现计数器和mutex" class="headerlink" title="用锁实现计数器和mutex"></a>用锁实现计数器和mutex</h4><p>看看如何开发一个线程安全的计数器类，它包含了<code>get()</code>  <code>increment()</code> <code>decrement()</code>操作。下面的代码展示了基于同步的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCounter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++value; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> --value; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <code>increment()</code> <code>decrement()</code>操作都是原子性的 <em>读-改-写</em>。这类操作在很多并发算法中都存在。下面的代码实现了一个简单的mutex，<code>acquire()</code>方法也是原子性的。获得mutex的前提没有其他线程已经获取了它，获取之后会把<code>curOwner</code>标记为当前线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMutex</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Thread curOwner = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Thread.interrupted()) <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        <span class="keyword">while</span> (curOwner != <span class="keyword">null</span>) </div><div class="line">            wait();</div><div class="line">        curOwner = Thread.currentThread();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (curOwner == Thread.currentThread()) &#123;</div><div class="line">            curOwner = <span class="keyword">null</span>;</div><div class="line">            notify();</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"not owner of mutex"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的计数器类能够很好的工作，但是在高度竞争的场景下，性能会急剧下降，因为JVM会花费较多的时间处理线程调度和管理等待线程队列，留给线程运行的时间就不多了。你应该还记得，上篇<a href="http://www.ibm.com/developerworks/java/library/j-jtp10264/" target="_blank" rel="external">文章</a> 展示了内建的监视器同步方法在竞争激烈时性能有多么糟吧。虽然那篇文章展示了<code>ReentrantLock</code>的可扩展性，但是对于某些问题，可能还有更好的实现方法。</p>
<h4 id="锁的问题"><a href="#锁的问题" class="headerlink" title="锁的问题"></a>锁的问题</h4><p>有了锁，如果一个线程尝试访问一个已经被其他线程持有的锁，那么这个线程会阻塞直到锁变得可用。这种机制有明显的缺陷，比如等待线程不能做其他任何事。如果高优先级的线程阻塞了，对于应用程序而言是一个灾难。</p>
<p>其他缺陷，比如死锁会导致更严重的问题。即便没发生这些问题，锁是一种粗粒度的协调机制，如果只是想管理一个简单的操作比如递增或是更新mutex值，锁太重了。如果能够有一种细粒度的机制，用于管理并发更新单个变量，是非常有好处的，幸运的是大多数现代处理器都提供了这样的支持。</p>
<h2 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h2><p>现代的处理器提供了并行处理的支持，包括多处理器共享外设和内存，以及改进的指令集。特别的，几乎每个现代处理器都有一种用于更新变量的指令，它可以检测或阻止多个处理器并发的访问。</p>
<h4 id="CAS指令"><a href="#CAS指令" class="headerlink" title="CAS指令"></a>CAS指令</h4><p>第一个支持并发的原子性<em>test-and-set</em>操作的处理器，只能在单个bit位上操作。现在的处理器都具备<em>compare-and-swap</em>操作。对于Intel处理器，CAS操作是通过cmpxchg指令集实现的；而PowerPC处理器有一对指令，load and reserve 和 store conditional；MIPS机器采用类似的方式，不过第一种指令被命名为load linked。</p>
<p>一个CAS操作包含三个操作数，内存地址V，期望的旧值A，新值B。如果V处的值和A相同，处理器可以将其更新为B，否则什么都不做。两种情况下，CAS的返回值都是CAS操作之前的值。CAS的语义是，我认为V处的值是A；如果确实是，那么更新为B，否则不要更改它，告诉我V处是什么值。将CAS用于同步的自然方式是读取V处的值A，进行多步计算得到新值B，使用CAS将变量从A更新到B。如果变量在计算结束时没有变动，那么CAS更新会成功。</p>
<p>CAS指令允许应用程序执行 <em>读-改-写</em> 操作，而无需担心另外的线程同时更新了变量，因为如果真了更改了，CAS操作会失败，算法可以感知到然后重新执行计算操作。下面的代码实现了CAS过程，但是CAS指令的价值在于它是硬件实现的，效率非常非常高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulatedCAS</span> </span>&#123;</div><div class="line">     <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"> </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</div><div class="line">         <span class="keyword">int</span> oldValue = value;</div><div class="line">         <span class="keyword">if</span> (value == expectedValue)</div><div class="line">             value = newValue;</div><div class="line">         <span class="keyword">return</span> oldValue;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="用CAS实现计数器"><a href="#用CAS实现计数器" class="headerlink" title="用CAS实现计数器"></a>用CAS实现计数器</h4><p>基于CAS的并发算法被称为无锁的，因为线程不需要等待锁。不管CAS操作有没有成功，它都会很快完成。如果CAS失败了，调用程序可以重新执行CAS，或者执行其他操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasCounter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> SimulatedCAS value;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.getValue();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> oldValue = value.getValue();</div><div class="line">        <span class="keyword">while</span> (value.compareAndSwap(oldValue, oldValue + <span class="number">1</span>) != oldValue)</div><div class="line">            oldValue = value.getValue();</div><div class="line">        <span class="keyword">return</span> oldValue + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="无锁和无等待算法"><a href="#无锁和无等待算法" class="headerlink" title="无锁和无等待算法"></a>无锁和无等待算法</h2><p>无等待算法是指每个线程都可以继续推进，即便其他线程无限期挂起。作为对比，无锁算法只要求部分线程可以始终推进。另一种定义方式是，无等待算法中每个线程都被保证可以在有限的执行次数内正确计算出结果。次数的上界可能是一个线程数量的函数，比如如果有十个线程，每个都执行<code>CasCounter.increment()</code>，最糟的情况下，某个线程会重试9次。</p>
<p>过去十五年，无等待算法和无锁(也称非阻塞nonblocking)算法收到了很多研究，无锁算法已经被应用到一些常见的数据结构中。无锁算法也已被用在操作系统和JVM中，用于线程进程调度。虽然它们很难实现，但是相比于基于锁的方法有很多优点，不会产生饥饿和死锁，竞争成本低，实现了更细粒度的协调，更高程度的并发。</p>
<h4 id="Atomic类"><a href="#Atomic类" class="headerlink" title="Atomic类"></a>Atomic类</h4><p>JDK5.0以前，不使用native代码的话，无法编写出无等待或是无锁的算法。有了<code>java.util.concurrent.atomic</code>包，情况就不一样了。原子变量类都有和CAS操作对应的方法，是用和硬件指令实现的。这个包提供了九个类，<code>java.util.concurrent.atomic</code> package (<code>AtomicInteger</code>; <code>AtomicInteger</code>; <code>AtomicReference</code>; <code>AtomicBoolean</code>; <code>AtomicIntegerArray</code>; <code>AtomicLongArray</code>; <code>AtomicReferenceArray</code>; <code>AtomicMarkableRefernce</code>, <code>AtomicStampedReference</code>。</p>
<p>原子变量类可以被认为是<code>volatile</code>变量的泛化，在<code>volatile</code>的可见性的基础上增加了原子性的CAS操作，读写原子变量具有读写<code>volatile</code>变量一样的内存语义。</p>
<p>虽然原子变量类表面上看起来就像前面实现的<code>SynchronizedCounter</code>，但这仅仅是看起来这样。在底层，atomic类的操作会被转化为底层的硬件指令。</p>
<h4 id="细粒度意味着轻量"><a href="#细粒度意味着轻量" class="headerlink" title="细粒度意味着轻量"></a>细粒度意味着轻量</h4><p>一种常用的优化并发程序性能的技术是减小锁的粒度，尝试降低某些获取锁过程的竞争激烈程度。使用原子性变量而不是锁可以达到同样的效果。</p>
<blockquote>
<p><strong>ABA问题</strong></p>
<p>CAS只判断当前值是否是期望值A，而存在一种可能，该变量被修改了多次，A-&gt;B-&gt;A最后一次把值改为了A，CAS操作是不能感知到这种变化的。这种情况下，CAS操作会成功，在某些场景中，这不是想要的结果。这被称为ABA问题，可以通过添加标版本号解决，版本号也必须用CAS操作更新。<code>AtomicStampedReference</code>就是这样实现的。</p>
</blockquote>
<h4 id="java-util-concurrent中的原子变量"><a href="#java-util-concurrent中的原子变量" class="headerlink" title="java.util.concurrent中的原子变量"></a><code>java.util.concurrent</code>中的原子变量</h4><p>这个包中的几乎所有类都使用的原子变量而不是同步。<code>ConcurrentLinkedQueue</code>类使用原子变量直接实现了无等待算法，<code>ConcurrentHashMap</code>使用<code>ReentrantLock</code>， 而<code>ReentrantLock</code>使用了原子变量维护等待线程队列。</p>
<p>这些类的实现都依赖于JDK5.0提供的硬件级别的同步原语。原子变量类和其他同步类，把这些特性提供给用户类。</p>
<h2 id="用变量变量实现更高的吞吐量"><a href="#用变量变量实现更高的吞吐量" class="headerlink" title="用变量变量实现更高的吞吐量"></a>用变量变量实现更高的吞吐量</h2><p><a href="http://www.ibm.com/developerworks/java/library/j-jtp10264/" target="_blank" rel="external">上篇</a>文章，我们看到了<code>ReentrantLock</code>提供了比<code>synchronized</code>更好的可扩展性，模拟了用伪随机数生成器的投骰子游戏。我展示了<code>synchronized</code>, <code>ReentrantLock</code>, 公平的 <code>ReentrantLock</code>的性能比较。现在，我会加入原子变量的结果，用<code>AtomicLong</code>更新PRNG状态。下面的代码展示了分别用同步和原子变量实现的PRNG。注意CAS操作必须写在一个循环中，因为它可能需要尝试多次才能成功，CAS操作一定要这样写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PseudoRandomUsingSynch</span> <span class="keyword">implements</span> <span class="title">PseudoRandom</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seed;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PseudoRandomUsingSynch</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; seed = s; &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> s = seed;</div><div class="line">        seed = Util.calculateNext(seed);</div><div class="line">        <span class="keyword">return</span> s % n;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PseudoRandomUsingAtomic</span> <span class="keyword">implements</span> <span class="title">PseudoRandom</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger seed;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PseudoRandomUsingAtomic</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</div><div class="line">        seed = <span class="keyword">new</span> AtomicInteger(s);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> s = seed.get();</div><div class="line">            <span class="keyword">int</span> nexts = Util.calculateNext(s);</div><div class="line">            <span class="keyword">if</span> (seed.compareAndSet(s, nexts))</div><div class="line">                <span class="keyword">return</span> s % n;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>图1 图2中的图展示了不同版本的随机数生成器的吞吐量。测试中的线程数量是模拟的，这些线程具备比通常情况高很多的竞争程度，所以<code>ReentrantLock</code>和<code>Atomic</code>有差不多的性能，通常情况下不会有这么多的线程。你会看到原子变量仍然有额外的性能提升，相比于已经不错的<code>ReentrantLock</code>。（随机数生成的任务太简单了，可能这个测试低估了原子变量的优势）</p>
<p><img src="https://www.ibm.com/developerworks/java/library/j-jtp11234/RngThroughput.gif" alt="图1 8-way Ultrasparc3"></p>
<p><img src="https://www.ibm.com/developerworks/java/library/j-jtp11234/RngThroughputUni.gif" alt="图2 单核Pentium 4"></p>
<p>大多数用户不太可能自己使用原子变量开发无锁算法，他们可能可能直接使用java提供的类，比如说<code>ConcurrentLinkedQueue</code>。但是如果你想知道这些类的性能提升来自何处时，我会告诉你是因为使用了细粒度的，硬件层次的同步原语。</p>
<p>开发者可能会发现有人直接使用原子变量作为共享计数器、序列生成器的替代品，其他的独立共享变量必须使用使用同步机制保护。（？）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JDK5.0在开发高性能的并发类方面走出了一大步。通过提供新的底层协调机制，以及一系列的同步变量类，现在开发无等待算法和无锁算法成为了可能。<code>java.util.concurrent</code>中的类都是使用这些底层的原子变量类构建的，带来了显著的可扩展性优势。虽然你可能不会直接使用原子变量类，但是它们的确是很有价值的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/16/深入探讨原子性/" data-id="cj56ttrpl0007z8jgutgoyuu1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Atomic/">Atomic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Brain-Goetz/">Brain Goetz</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同步/">同步</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/译文/">译文</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-同步锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/05/同步锁/" class="article-date">
  <time datetime="2017-07-05T15:05:18.000Z" itemprop="datePublished">2017-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/05/同步锁/">同步锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.ibm.com/developerworks/java/library/j-jtp10264/index.html?ca=drs-" target="_blank" rel="external">原文链接</a></p>
<p>多线程和并发不是新话题，但是Java首先将跨平台的线程模型和内存模型纳入到语言特性中。核心库包括了<code>Thread</code>类，可以用于创建、启动和维护线程，另外还包含了可用于添加线程并发约束的关键字<code>synchronized</code>和<code>volatile</code>。虽然这些类和特性简化了并发类的开发，但不意味着那变得很容易。</p>
<h2 id="synchronized简介"><a href="#synchronized简介" class="headerlink" title="synchronized简介"></a><code>synchronized</code>简介</h2><p>将一段代码声明为<code>synchronized</code>会带来两个重要的效果，原子性和可见性。原子性意味着任意时间点只有一个线程可以执行这段代码，这可以用来避免多个线程更新共享变量的冲突。可见性与内存缓存和编译器优化相关。通常，线程拥有缓存变量的能力，这会导致变量的修改不会立即对其他线程可见。但是，如果开发者使用了同步，运行时<code>synchronized</code>段内的代码所产生的修改一定会对之后其他执行该段代码的线程可见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (lockObject) &#123; </div><div class="line">  <span class="comment">// update object state</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>volatile</code>有类似的作用。所以同步机制能够可靠的更新共享变量，保证其他同步线程可以看到最新的变量值。这种清晰、跨平台的的内存模型使得创建”编写一次，随处运行”的并发类成为了可能。下面的实现规则很简单。</p>
<p><strong>任何时候，读一个刚好可能正在被其他线程写的变量，必须使用同步</strong></p>
<p>最近（2004年底）的JVM对锁执行进行了优化，当不存在多个线程竞争锁时，同步代码的成本不会太高。</p>
<h2 id="改进synchronized"><a href="#改进synchronized" class="headerlink" title="改进synchronized"></a>改进<code>synchronized</code></h2><p>似乎前面讲的同步方法已经很好了？但是为什么JSR166组花了很长时间开发<code>java.util.concurrent.lock</code>呢？<code>synchronized</code>确实不错，但是远不完美。它有一些功能上的缺陷，这种方式不能中断一个正在等待获取锁的线程，也不能poll for a lock。<code>synchronized</code>同步机制要求锁在同一个栈上获取和释放，大多数情况下这没错。但是少数情形中，非阻塞结构锁(non-block-structured locking)更好。</p>
<h2 id="ReentrantLock类"><a href="#ReentrantLock类" class="headerlink" title="ReentrantLock类"></a><code>ReentrantLock</code>类</h2><p><code>java.util.concurrent.lock</code>提供了加锁的抽象，允许你自己实现同步而不是简单采用<code>synchronized</code>。同时它提供了多种同步实现，包含了不同的调度算法、性能特点或同步语义。<code>ReentrantLock</code>类实现了<code>Lock</code>接口，具有和<code>synchronized</code>相同的并发和内存语义，但是还有额外的特性，比如lock polling，计时等待，中断等待。另外，它在大量线程竞争锁的场景下的性能有很大的改进。</p>
<p>为什么叫<em>reentrant</em>锁？有一个计数器和锁关联，当一个持有锁的线程再次申请该锁时，计数器会加一，如果要释放该锁，必须有两次释放操作。这和<code>synchronized</code>一样，如果一个线程正在执行<code>synchronized</code>内的代码，再遇到一个<code>synchronized</code>也可以继续执行，只是需要退出第一个<code>synchronized</code>后锁才得到释放。</p>
<p>下面的代码是<code>ReentrantLock</code>的一个简单例子，注意<code>finally</code>语句十分重要，必须通过<code>finally</code>释放锁，否则如果<code>try</code>块中抛出了异常，该锁永远不会得到释放。这听起来很简单，但是极度重要。忘记使用<code>finally</code>释放锁会给应用程序埋下一个定时炸弹，而且爆炸时很难追踪。<code>synchronized</code>不存在这样的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"> </div><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123; </div><div class="line">  <span class="comment">// update object state</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">  lock.unlock(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ReentrantLock</code>的优势是高并发下的可扩展性(不知道现在的JVM版本对<code>synchronized</code>的竞争性能有没有优化？)。</p>
<h2 id="ReentrantLock和synchronized可扩展性对比"><a href="#ReentrantLock和synchronized可扩展性对比" class="headerlink" title="ReentrantLock和synchronized可扩展性对比"></a><code>ReentrantLock</code>和<code>synchronized</code>可扩展性对比</h2><p>Time Peierls构建了一个简单的评测方式，用于衡量这两者的扩展性，实现是基于线性一致伪随机数生成器(PRNG)。这个例子很贴切因为<code>nextRandom()</code>有调用到PRNG，所以这个评测实际上衡量了<code>ReentrantLock</code>和<code>synchronized</code>。</p>
<p>在这个评测中，我们有一个接口<code>PseudoRandom</code>，有唯一的方法<code>nextRandom(int bound)</code>。这个接口的功能和<code>java.util.Random</code>非常相似。因为PRNG会使用上次生成的随机数作为下次调用的参数，所以确保修改这个状态的代码不被其他线程抢占十分重要，需要加锁来保证。我们创建了<code>PseudoRandom</code>的两种实现，一种使用同步关键字，另一种使用<code>ReentrantLock</code>。驱动程序启动一些线程，每个线程不间断的模拟摇骰子，然后计算每秒钟摇的次数。图1和图2展示了结果。</p>
<p><img src="https://www.ibm.com/developerworks/java/library/j-jtp10264/figure1.jpg" alt="图1 吞吐量"></p>
<p><img src="https://www.ibm.com/developerworks/java/library/j-jtp10264/figure2.jpg" alt="图2"></p>
<p>上面两图的曲线展示了两种实现下，每个线程每秒钟的吞吐量。随着线程数量增加，两种实现的吞吐量都能很快达到收敛值，这意味着处理器得到了完全的利用，部分时间用于生成随机数，部分时间用在调度上。你会注意到<code>synchronized</code>在线程数较多时的性能非常差，花了大量的时间在线程调度上，但是<code>Lock</code>就不存在这样的缺陷。</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p><code>Object</code>类包含了几个特别的方法，用于线程见通信 — <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>。有经验的程序员从来不使用它们，它们非常脆弱，容易出错。幸运的是，JDK5.0引入了<code>java.util.concurrent</code>。</p>
<p>如果要调用一个对象的notify或者wait，你必须持有那个对象的锁。就像Lock是同步的抽象，Condition是wait和notify的抽象。一个Lock对象扮演着相关联的条件变量的工厂角色，不同于wait和notify的是，一个Lock可以产生对个关联的条件。这简化了很多并发算法的开发。比如，Condition的JavaDoc中展示了一个例子，使用两个锁实现有界限的缓冲区，’not full’和’not empty’更加可读，也更有效率。Condition的类似于wait notify notifyAll的方法，被命名为await signal signalAll，因为它们不能覆盖Object的那些方法。</p>
<h2 id="那不公平"><a href="#那不公平" class="headerlink" title="那不公平"></a>那不公平</h2><p>如果仔细阅读JavaDoc，你会发现<code>ReentrantLock</code>的构造方法有一个boolean参数，让你选择构造一个公平的还是不公平的锁。公平锁意味着线程会按照申请的时间先后顺序获得锁，不公平锁不保证这一点。</p>
<p>为什么需要这个参数？把所有锁都设置为公平的有什么不好吗？问题在于公平性是有代价的。要保证公平必须使用同步，这会导致吞吐量的大幅下降，相比于非公平锁。大多数时候使用默认的false参数(不公平)就可以了，除非你的应用依赖于线程必须按照申请顺序获得锁。</p>
<p><code>synchronized</code>呢？内建的监视器锁公平吗？答案是no。但是从没有人抱怨线程饥饿，因为JVM保证了所有线程最终会获得锁。大多数情况下，大致公平就足够了，成本远低于绝对公平。如果你觉得<code>synchronized</code>没有问题，那么也不要担心<code>ReentrantLock</code>。</p>
<p>图3和图4包含了图1、图2相同的数据，添加了公平锁的情况。你可以看到公平性是有成本的。除非你真的需要，不要使用这种锁。</p>
<p><img src="https://www.ibm.com/developerworks/java/library/j-jtp10264/figure3.jpg" alt="图3"></p>
<p><img src="https://www.ibm.com/developerworks/java/library/j-jtp10264/figure4.jpg" alt="图4"></p>
<h2 id="还有其他好处吗？"><a href="#还有其他好处吗？" class="headerlink" title="还有其他好处吗？"></a>还有其他好处吗？</h2><p>似乎<code>ReentrantLock</code>在每个方面都比<code>synchronized</code>好，它具有<code>synchronized</code>一样的功能，具有相同的内存和并发语义，具有<code>synchronized</code>没有的特性，有更好的并发性能。所以，似乎我们应该丢掉<code>synchronized</code>？甚至应该用<code>ReentrantLock</code>重写所有的<code>synchronized</code>？实际上，有一些Java入门书已经采取了这种意见，一律使用Lock，而不要使用<code>synchronized</code>。</p>
<h4 id="现在丢弃synchronized为时过早"><a href="#现在丢弃synchronized为时过早" class="headerlink" title="现在丢弃synchronized为时过早"></a>现在丢弃<code>synchronized</code>为时过早</h4><p>虽然<code>ReentrantLock</code>是一个非常好的同步实现方式，但是我认为把<code>synchronized</code>当做一个过时的特性是一个严重的错误。<code>java.util.concurrent.lock</code>是面向高级用户和复杂场景的工具。通常，你可以使用简单的<code>synchronized</code>除非确实需要<code>Lock</code>的特性，或者你有证据表明锁的可扩展性是性能瓶颈。</p>
<p>为什么我要提这一点？其实<code>synchronized</code>有一些优点的。</p>
<p>首先，使用<code>synchronized</code>不会忘记释放锁，JVM保证了这一点。使用<code>Lock</code>时有可能忘记使用<code>finally</code>释放锁，这取决于程序员的实现。你的程序会通过测试，在真正出现问题时难以调试，所以我不建议初级开发者使用<code>Lock</code>。其次，如果是JVM负责管理锁的获取和释放，那么JVM在dump文件中包含这些信息。这些信息对于调试非常有价值，因为它们包含了发现死锁或其他错误行为的线索。Lock是普通类，JVM不知道哪个它被哪个线程拥有。然后，<code>synchronized</code>对于所有开发者都很熟悉，可以运行在所有JVM版本上。</p>
<h2 id="何时选择ReentrantLock"><a href="#何时选择ReentrantLock" class="headerlink" title="何时选择ReentrantLock"></a>何时选择<code>ReentrantLock</code></h2><p>答案非常简单，当你真的需要它的特性时，包括计时等待、中断等待，非阻塞结构锁，多重条件，锁polling。<code>ReentrantLock</code>有可扩展性的优势，在高并发高竞争的场景中使用它。我会建议首先使用<code>synchronized</code>，除非你有证据表明它的性能不够，而不仅仅凭直觉认为<code>ReentrantLock</code>就可以获得更好的性能。记住，这是高级用户的高级工具，(真正的高级用户倾向于使用最简单够用的工具)。一个在很多时候都适用的道理是，先保证把事情做正确，不要一开始就想着要达到最好的效率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Lock</code>框架是<code>synchronized</code>的替代，提供了很多额外的特性。然而这并不意味着你一定要使用<code>ReentrantLock</code>。你首先要准确的判断是否需要这些新特征。大多数情况下，答案是no，<code>synchronized</code>就足够了，它和JVM协同工作，被广泛的开发者理解，能够在所有的JVM版本上运行，不容易出错。</p>
<p>在真正需要的时候使用<code>Lock</code>，你会很享受它的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/05/同步锁/" data-id="cj56ttrpo0008z8jg1d6t3y4h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Brain-Goetz/">Brain Goetz</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/同步/">同步</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/译文/">译文</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-软引用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/01/软引用/" class="article-date">
  <time datetime="2017-07-01T09:01:02.000Z" itemprop="datePublished">2017-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/01/软引用/">软引用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="用软引用堵住内存泄露"><a href="#用软引用堵住内存泄露" class="headerlink" title="用软引用堵住内存泄露"></a>用软引用堵住内存泄露</h1><p><a href="https://www.ibm.com/developerworks/java/library/j-jtp01246/index.html?ca=drs-" target="_blank" rel="external">Brian Goetz原文链接</a></p>
<p>GC使得Java程序不再发生内存泄露，至少对于狭窄定义的内存泄露是成立的，但是这并不意味着我们可以完全不关注程序中的对象的生命周期。Java中的内存泄露的产生，通常是由于我们忽略或者是错误的管理了对象的生命周期。比如，<a href="http://www.ibm.com/developerworks/java/library/j-jtp11225/index.html" target="_blank" rel="external">上篇文章</a>里解释了，错误的生命周期定义会导致意外的对象滞留，它发生于当我们试图把transient对象和类成员关联起来的时候。另外，某些其他的习惯会忽略或扰乱对象生命周期管理，从而导致内存泄露。</p>
<h2 id="悬空对象-Object-loitering"><a href="#悬空对象-Object-loitering" class="headerlink" title="悬空对象 (Object loitering)"></a>悬空对象 (Object loitering)</h2><p>下面的代码展示了一种内存泄露，称之为<em>object loitering</em>(游荡). 函数<code>getFileChecksum</code>的作用是计算一个文件的校验值，它首先会读取文件内容到一个buffer。对于变量<code>byteArray</code>，更直接的实现方式是将其声明为函数的局部变量，但是这里使用了似乎更加聪明的方式，将其设置为一个成员变量，重用以避免每次调用都分配空间。这种’优化’并没有真正带来加速，内存分配并不如想象的那么耗时。(注意把buffer变量设置为成员变量还会带来线程安全性的问题，而局部变量不会。)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BAD CODE - DO NOT EMULATE</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakyChecksum</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] byteArray;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getFileChecksum</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = getFileSize(fileName);</div><div class="line">        <span class="keyword">if</span> (byteArray == <span class="keyword">null</span> || byteArray.length &lt; len)</div><div class="line">            byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</div><div class="line">        readFileContents(fileName, byteArray);</div><div class="line">        <span class="comment">// calculate checksum and return it</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类可能有很多问题，但这里主要讨论内存泄露方面的。如果<code>getFileChecksum</code>函数会被频繁调用，重用buffer是的确可以带来性能提升。但是，buffer从来不会被释放，因为它始终是可达的(reachable). (除非<code>LeakyChecksum</code>对象不存在了) 更糟糕的是，当读取的文件越来越大时，buffer也会随之增大；而后读取小文件时，之前分配的大空间不会被回收，<code>LeakyChecksum</code>的buffer始终等于处理过的最大文件的空间。所以为了复用而保留一个很搭的buffer不是最高效的内存利用方式。</p>
<p><code>LeakyChecksum</code>的缺陷的根本原因是buffer成员是对于<code>getFileChecksum</code>函数局部有效的，但是它的生命周期被提升到和对象一样了。JVM的GC此时发挥不了作用，必须靠类本身管理对象和内存。</p>
<h2 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a>软引用(Soft Reference)</h2><p><a href="http://www.ibm.com/developerworks/java/library/j-jtp11225/index.html" target="_blank" rel="external">上篇文章</a>里，我们看到了弱引用(weak reference)可以提供另外一种意义上的可达性(reaching), 但是没有延长对象的生命周期。<code>Reference</code>的另一个子类，<code>SoftReference</code>可以实现这样的功能。<code>WeakReference</code>允许程序创建不限制于GC规则约束的对象，而<code>SoftReference</code>利用GC的帮助为对象增加<em>可消耗(expendable)</em>的性质。虽然GC确实能够很好的判断判断内存块是否在使用，但内存是否被有效利用最大程度上取决于程序。如果程序使用了不好的策略，GC会频繁运行。</p>
<p>缓存(caching)是一种常见的性能优化方法，它尽可能的重用之前的结果而不是每次都直接计算。缓存是利用CPU和利用内存的折中，理想的平衡点取决于可用内存有多少。太少缓存不能达到期望的性能提升，太多缓存也可能导致性能下降因为用于其他任务的空间变少了。相比程序自身，GC通常能够更好的管理内存，很自然的我们应该利用GC。<code>SoftReference</code>就是这样做的。</p>
<p>如果一个对象只被<code>WeakReference</code>引用，那么称该对象<em>弱可达(weakly reachable)</em>. 如果一个对象只被<code>SoftReference</code>(和<code>WeakReference</code>)引用，那么称该对象<em>软可达(softly reachable)</em>. GC对出于这两种状态的对象的行为是不同的。前者，GC会激进的回收掉该对象的空间，后者，回收仅发生于内存不够用时。软引用告诉GC，”只要内存不是太紧张，保留该对象；内存真的不够用时，回收掉它吧，程序会处理好之后的事情的。” 只有在情绪了所有的软可达对象后空间仍然不够时，GC才会抛出OutOfMemoryError。</p>
<p>我们可以通过使用<code>SoftReference</code>管理缓存buffer，以修复<code>LeakyChecksum</code>的问题。现在buffer在大多数时候可以得到重用，而内存真的不够用时，它可以被回收以释放空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingChecksum</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt; bufferRef;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getFileChecksum</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = getFileSize(fileName);</div><div class="line">        <span class="keyword">byte</span>[] byteArray = bufferRef.get();</div><div class="line">        <span class="keyword">if</span> (byteArray == <span class="keyword">null</span> || byteArray.length &lt; len) &#123;</div><div class="line">            byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</div><div class="line">            bufferRef.set(byteArray);</div><div class="line">        &#125;</div><div class="line">        readFileContents(fileName, byteArray);</div><div class="line">        <span class="comment">// calculate checksum and return it</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="简易缓存"><a href="#简易缓存" class="headerlink" title="简易缓存"></a>简易缓存</h2><p><code>CachingChecksum</code>使用<code>SoftReference</code>缓存单个对象，JVM会知道何时移除缓存。类似的，<code>SoftReference</code>经常用在GUI应用中，缓存图像。能否使用<code>SoftReference</code>取决于程序能不能应对缓存数据的丢失。</p>
<p>如果需要缓存多个对象，可以使用一个Map。有两种实现方式， <code>Map&lt;K, SoftReference&lt;V&gt;&gt;</code> 或者 <code>SoftReference&lt;Map&lt;K,V&gt;&gt;</code>后一种更好，因为它让GC的负担更小，当内存不够时，可以很容易的移掉整个缓存以换得大量空间。<code>WeakReference</code>并不适合用于实现缓存，因为它引用的对象会在被频繁执行的MinorGC回收，通常还没等到下一次被访问到。这不符合缓存的意义。</p>
<p>然而，对于那些性能严重依赖缓存的应用，<code>SoftReference</code>是一个笨拙的工具，专门的缓存框架更合适，它们能够提供灵活的过期时间设置，拷贝和事务化。但是作为一个便宜的缓存机制，<code>SoftReference</code>还是很有性价比的。</p>
<p>和<code>WeakReference</code>一样，<code>SoftReference</code>在创建的时候可以和一个队列关联，当<code>Reference</code>被回收时，也会被插入到关联队列中。软引用的队列不如弱引用中的队列那么有用，但是它可以作为内存不足的警告。</p>
<h2 id="GC如何处理Reference"><a href="#GC如何处理Reference" class="headerlink" title="GC如何处理Reference"></a>GC如何处理<code>Reference</code></h2><p><code>WeakReference</code>和<code>SoftReference</code>都是<code>Reference</code>的子类，此类对象会被GC特别处理。当GC在扫描堆空间的过程中遇到Reference对象时，它不会标记或追踪其引用的实际对象，而只把<code>Reference</code>对象放在一个队列中。扫描结束后，GC会甄别队列中的<code>SoftReference</code>对象，然后根据当前的内存状况决定是否回收实际对象。部分<code>SoftReference</code>的实际对象会被回收，剩下的被GC当做根节点继续标记。</p>
<p>处理完<code>SoftReference</code>后，队列里剩下的是<code>WeakReference</code>，它们全部都会被回收。两种<code>Reference</code>在被压入关联队列前，其实际对象一定已经被清除掉了，所以处理后续工作的线程只能访问到<code>Reference</code>而不能访问到实际对象。</p>
<h2 id="Reference的成本"><a href="#Reference的成本" class="headerlink" title="Reference的成本"></a><code>Reference</code>的成本</h2><p><code>Reference</code>对象会给GC过程引入额外的成本。每次GC必须构建一个包含所有<code>Reference</code>的列表，每个<code>Reference</code>必须被恰当的处理，不论其实际对象有没有被清楚，都会消耗时间。<code>Reference</code>对象自身有可能会被清理，这种情况下，其不会被插入关联队列。</p>
<h2 id="基于数组的集合"><a href="#基于数组的集合" class="headerlink" title="基于数组的集合"></a>基于数组的集合</h2><p>另一种形式的对象悬空发生于基于数组的数据结构中。<code>LeakyStack</code>类是一个例子。<code>pop()</code>方法执行后，弹出对象的引用依然存在于<code>elements</code>中。这意味着弹出的对象的空间永远不会被GC回收，即便程序再也无法访问到它。知道那个位置被<code>push()</code>另一个元素时，该块内存才得以利用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakyStack</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object[] elements = <span class="keyword">new</span> Object[MAX_ELEMENTS];</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span> </span>&#123; elements[size++] = o; &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            Object result = elements[--size];</div><div class="line">            <span class="comment">// elements[size+1] = null;</span></div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种对象悬空的解决方法是<code>pop()</code>之后把<code>elements</code>中的元素置为<code>null</code>，如上面的代码中注释掉的那行所示。然而，这并不是一种好的方法。大多数置空操作不会带来任何性能提升，整体上反而导致更糟糕的性能甚至<code>NullPointerException</code>错误。基于链表的<code>Stack</code>实现就没有对象悬空的问题，对象的生命周期和元素的存在时期自动的保持一致。<code>WeakReference</code>可以用来修复<code>LeakyStack</code>的问题（维护一个弱引用数组而非强引用。！疑问：这样实现，<code>push</code>进去的元素可能在<code>pop</code>之前就已经被GC了？），然而<code>LeakyStack</code>采取了自己清除不需要的对象的方式。用数组实现<code>Stack</code>可以避免反复的内存分配，但是增加了开发者手动管理内存的负担。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>SoftReference</code>和<code>WeakReference</code>类似，可以帮助程序避免对象悬空，利用GC清除不是十分必要存在的对象。<code>SoftReference</code>仅仅适合于程序能够处理对象丢失的情形。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/01/软引用/" data-id="cj56ttrpj0005z8jg2d6l5vlq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Brain-Goetz/">Brain Goetz</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/译文/">译文</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Builder构建器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/28/Builder构建器/" class="article-date">
  <time datetime="2017-06-28T06:40:03.000Z" itemprop="datePublished">2017-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/Builder构建器/">Builder构建器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用过Python语言的同学们肯定知道，函数的参数有positional和keyword两种类型，第一种就是广泛存在于Java C++中的参数，按位置识别，第二种是用名字标识的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># define</div><div class="line">def func(a, b, c='X', d='Y')</div><div class="line"># invoke</div><div class="line">func('a', 'b')</div><div class="line">func('a', 'b', d='x')</div></pre></td></tr></table></figure>
<p>容易看出，keyword形式具有更强的表达力，可以让使用者明白每个参数的意义，并且调用时也更加灵活。Java中参数不能有名字和默认值。那么如果构建有很多个成员变量的类时该如何设计呢？一种直观的方式是POJO</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> year;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> month;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> day;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">this</span>.year = y; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setMonth</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">this</span>.month = m; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setDay</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123; <span class="keyword">this</span>.day = d; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式是可行的，它使得构建实例变得非常直观，你不需要记住构造函数的每个位置是什么参数。它的问题是，不能很好的检查参数的有效性，特别是当成员变量有关联性的时候，比如无法上面的类无法阻止用户创建2月30号这样的无效日期。上一篇文章讲解的静态工厂方法可以解决这个问题，但是无法提供参数的语义信息。使用Builder辅助类是一个好的办法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> year;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> month;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> day;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Date</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Date</span><span class="params">(Builder b)</span> </span>&#123;</div><div class="line">    Date d = <span class="keyword">new</span> Date();</div><div class="line">    d.year = b.year;</div><div class="line">    d.month = b.month;</div><div class="line">    d.day = b.day;</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">year</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">this</span>.year = y; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">month</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">this</span>.month = m; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">day</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123; <span class="keyword">this</span>.day = d; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">build</span><span class="params">()</span> throw Exception </span>&#123;</div><div class="line">      <span class="comment">// validate the date</span></div><div class="line">      <span class="keyword">if</span> (validate()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> Exception();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// valid</span></div><div class="line">Date = <span class="keyword">new</span> Date.Builder().year(<span class="number">2017</span>).month(<span class="number">1</span>).day(<span class="number">1</span>).build();</div><div class="line"><span class="comment">// invalid setting will thorws an exception</span></div><div class="line">Date = <span class="keyword">new</span> Date.Builder().year(<span class="number">2017</span>).month(<span class="number">2</span>).day(<span class="number">30</span>).build();</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/28/Builder构建器/" data-id="cj56ttrp10000z8jg2o8o3nva" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EffectiveJava/">EffectiveJava</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/构造/">构造</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-创建和销毁对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/27/创建和销毁对象/" class="article-date">
  <time datetime="2017-06-27T13:35:13.000Z" itemprop="datePublished">2017-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/27/创建和销毁对象/">创建和销毁对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于类的使用者，获取实例的方式通常是调用该类的构造方法。构造方法是一种特殊的方法，它的名字只能和类名相同。如果要允许不同创建方式，只能构建参数签名不同的构造方法。另外，每调用一次构造方法，就会有一个新的对象产生，这在某些场景下不适用，比如单(多)例模式。简单的说，构造方法的灵活性不够。当然，得到类实例不一定通过构造方法，普通的method同样可以返回对象。通常把静态的，返回类型和所属类相同的方法称为factory method。它具有以下几点优势。</p>
<h4 id="有名称"><a href="#有名称" class="headerlink" title="有名称"></a>有名称</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDouble</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MyDouble</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyDouble <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyDouble <span class="title">parseFrom</span><span class="params">(String x)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="重用对象"><a href="#重用对象" class="headerlink" title="重用对象"></a>重用对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>;</div><div class="line">  <span class="keyword">private</span> Single single;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (single == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">synchronized</span>(Single.class) &#123;</div><div class="line">        <span class="keyword">if</span> (single == <span class="keyword">null</span>) &#123;</div><div class="line">          single = <span class="keyword">new</span> Single();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> single;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="灵活的返回子类"><a href="#灵活的返回子类" class="headerlink" title="灵活的返回子类"></a>灵活的返回子类</h4><p>API可以通过静态工厂方法返回对象，但不必把对象的类变成共有的。例如java.util.Collections提供了不可修改的集合、同步集合，所有返回对象的类都是非共有的。这种设计可以强制客户端通过接口来引用返回对象，而不是实现类，这是一种良好的习惯。接口引用的好处是可以修改实现而不影响现有的代码。</p>
<h4 id="更简单的参数化构造"><a href="#更简单的参数化构造" class="headerlink" title="更简单的参数化构造"></a>更简单的参数化构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">HashMap&lt;K, V&gt; <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K, V&gt;();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 类型推断</span></div><div class="line">Map&lt;String, Integer&gt; m = newInstance();</div></pre></td></tr></table></figure>
<p>vs</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</div><div class="line"><span class="comment">// 不过JDK7中已经有了更好的类型推断</span></div><div class="line">Map&lt;String, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</div></pre></td></tr></table></figure>
<p>“No free lunch”告诉我们，好处总是有成本的。引入静态工厂方法的类，通常会屏蔽掉其构造函数，通过private访问标识，这样类不能够再被继承，因为Java中规定了子类构造函数必须调用父类构造函数。另一点是，工厂构造方法和类中的普通静态方法没有任何区别，生成的JavaDoc里它们会被放在一起，而不会像构造方法那样单列在一个类别。这对于类的使用者来说，可能不那么方便，需要浏览所有static方法才能知道如何构造实例。也许JavaDoc应该加入对静态工厂方法的支持。目前的缓解方式是命名约束</p>
<ul>
<li>getInstance 获得对象，可能是新的，可能是已有的</li>
<li>newInstance 生成新对象</li>
<li>newSubTypeA 获得某个子类对象</li>
<li>build 某些需要复杂构造过程的类有Builder类，比如URL</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/27/创建和销毁对象/" data-id="cj56ttrpg0004z8jgfraunsy0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EffectiveJava/">EffectiveJava</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/构造/">构造</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/27/hello-world/" class="article-date">
  <time datetime="2017-06-27T12:31:58.000Z" itemprop="datePublished">2017-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/27/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/27/hello-world/" data-id="cj56ttrp80001z8jg3jyhj2ox" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Atomic/">Atomic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Brain-Goetz/">Brain Goetz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EffectiveJava/">EffectiveJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/同步/">同步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构造/">构造</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/译文/">译文</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Atomic/" style="font-size: 10px;">Atomic</a> <a href="/tags/Brain-Goetz/" style="font-size: 16.67px;">Brain Goetz</a> <a href="/tags/EffectiveJava/" style="font-size: 13.33px;">EffectiveJava</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/同步/" style="font-size: 13.33px;">同步</a> <a href="/tags/构造/" style="font-size: 13.33px;">构造</a> <a href="/tags/译文/" style="font-size: 16.67px;">译文</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/16/Java动态编译技术/">Java动态编译技术</a>
          </li>
        
          <li>
            <a href="/2017/07/16/深入探讨原子性/">深入探讨原子性</a>
          </li>
        
          <li>
            <a href="/2017/07/05/同步锁/">同步锁</a>
          </li>
        
          <li>
            <a href="/2017/07/01/软引用/">软引用</a>
          </li>
        
          <li>
            <a href="/2017/06/28/Builder构建器/">Builder构建器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Brav3heart<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>